name: CI

on:
  push:
    branches: [ main ]

jobs:
  build_and_test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Compose and Build services
        working-directory: ./ultradex
        run: |
          set -e # Ensure script exits on first error
          echo "Running docker compose build..."
          docker compose build > $GITHUB_WORKSPACE/docker_build_output.log 2>&1
          BUILD_EXIT_CODE=$?
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "Docker compose build failed with exit code $BUILD_EXIT_CODE. Full log:"
            cat $GITHUB_WORKSPACE/docker_build_output.log
            exit $BUILD_EXIT_CODE
          fi
          echo "Docker compose build successful."

          echo "Running docker compose up -d..."
          docker compose up -d > $GITHUB_WORKSPACE/docker_up_output.log 2>&1
          UP_EXIT_CODE=$?
          if [ $UP_EXIT_CODE -ne 0 ]; then
            echo "Docker compose up -d failed with exit code $UP_EXIT_CODE. Full log:"
            cat $GITHUB_WORKSPACE/docker_up_output.log
            # Also output build log for context if up fails, as it might be related
            echo "--- Docker Build Log (for context as 'up' failed) ---"
            cat $GITHUB_WORKSPACE/docker_build_output.log
            exit $UP_EXIT_CODE
          fi
          echo "Docker compose up -d successful."

      - name: Debug Container Environment
        working-directory: ./ultradex
        run: |
          docker compose exec -T --user root app sh -c "\
          echo '--- Running as root ---'; \
          whoami; \
          pwd; \
          echo 'Listing /usr/src/app as root:'; \
          ls -la /usr/src/app; \
          echo 'Permissions of /usr/src/app/Gemfile.lock as root:'; \
          stat /usr/src/app/Gemfile.lock || echo 'Gemfile.lock not found by root'; \
          echo 'Verifying appuser existence and details:'; \
          id appuser || echo 'appuser not found'; \
          cat /etc/passwd | grep appuser || echo 'appuser not in /etc/passwd'; \
          echo 'Root environment variables:'; \
          env; \
          echo 'Attempting chmod 777 /usr/src/app/Gemfile.lock as root:'; \
          cd /usr/src/app && chmod -v 777 Gemfile.lock || echo 'chmod as root failed or Gemfile.lock not found in /usr/src/app'; \
          echo 'Listing /usr/src/app after root chmod:'; \
          ls -la /usr/src/app; \
          echo '--- Switching to appuser for further checks ---'; \
          echo 'Running tests as appuser via su appuser -c \"...\"'; \
          su appuser -c \"\
          echo '--- Running as appuser (via su appuser -c) ---'; \
          whoami; \
          pwd; \
          echo 'Sourcing RVM...'; \
          source /home/appuser/.rvm/scripts/rvm && echo 'RVM Sourced. Ruby version:' && ruby -v || echo 'RVM Sourcing FAILED or ruby -v failed'; \
          echo 'Attempting cd /usr/src/app as appuser (after RVM source)...'; \
          cd /usr/src/app && echo 'cd /usr/src/app successful. New pwd:' && pwd || echo 'cd /usr/src/app FAILED'; \
          echo 'Listing /usr/src/app as appuser:'; \
          ls -la; \
          echo 'Listing /usr/src/app/config as appuser:'; \
          ls -la config || echo '/usr/src/app/config NOT FOUND or not listable by appuser'; \
          echo 'Verifying config/environment.rb from PWD:'; \
          ls -la config/environment.rb || echo 'config/environment.rb NOT FOUND from PWD'; \
          echo 'Verifying spec/rails_helper.rb from PWD:'; \
          ls -la spec/rails_helper.rb || echo 'spec/rails_helper.rb NOT FOUND from PWD'; \
          echo 'appuser environment variables:'; \
          env; \
          echo 'Specific Bundler/Ruby Env Vars:'; \
          echo BUNDLE_GEMFILE: \\\$BUNDLE_GEMFILE; \
          echo RUBYLIB: \\\$RUBYLIB; \
          echo GEM_HOME: \\\$GEM_HOME; \
          echo GEM_PATH: \\\$GEM_PATH; \
          echo 'Running bundle check (output will follow):'; \
          bundle check || echo 'Bundle check FAILED'; \
          echo 'Ruby \\\$LOAD_PATH under bundle exec (from /usr/src/app):'; \
          bundle exec ruby -e 'puts \\\$LOAD_PATH' || echo 'Failed to get \\\$LOAD_PATH'; \
          echo 'Content of spec/rails_helper.rb:'; \
          cat spec/rails_helper.rb || echo 'Failed to cat spec/rails_helper.rb'; \
          echo 'Attempting to require /usr/src/app/config/environment.rb directly via bundle exec ruby:'; \
          bundle exec ruby -e \\\"begin; puts 'Attempting to load /usr/src/app/config/environment.rb'; require '/usr/src/app/config/environment.rb'; puts 'Successfully required /usr/src/app/config/environment.rb'; rescue Exception => e; puts \\\\\\\"Failed to require /usr/src/app/config/environment.rb: \#{e.class} \#{e.message}\\\\\\\"; puts e.backtrace.join('\\\\n'); exit 1; end\\\" || echo 'Ruby direct require test returned error'; \
          echo 'Attempting to require_relative ../config/environment from /usr/src/app/spec context via bundle exec ruby:'; \
          bundle exec ruby -e \\\"Dir.chdir('/usr/src/app/spec'); begin; puts 'Attempting to load ../config/environment from /usr/src/app/spec'; require_relative '../config/environment'; puts 'Successfully required_relative ../config/environment from spec/'; rescue Exception => e; puts \\\\\\\"Failed to require_relative ../config/environment from spec/: \#{e.class} \#{e.message}\\\\\\\"; puts e.backtrace.join('\\\\n'); exit 1; end\\\" || echo 'Ruby require_relative test returned error'; \
          set +x; \
          \" \
          "

      - name: Run RSpec tests
        working-directory: ./ultradex
        run: |
          docker compose exec -T --user root app sh -c "cd /usr/src/app && chmod 777 Gemfile.lock || true; su appuser -c 'source /home/appuser/.rvm/scripts/rvm && cd /usr/src/app && bundle exec rspec'"

      - name: Output Failure Logs
        if: failure()
        working-directory: ./ultradex # pwd is $GITHUB_WORKSPACE/ultradex
        run: |
          BUILD_LOG_FILE="$GITHUB_WORKSPACE/docker_build_output.log"
          UP_LOG_FILE="$GITHUB_WORKSPACE/docker_up_output.log"
          PROCESSED_BUILD_OR_UP_ERROR=false

          # Intentionally minimal echos now, only outputting found errors or final status.

          if [ -f "$BUILD_LOG_FILE" ]; then
            # Grep for critical errors, show only matching lines.
            # Added 'npm: not found' directly based on observed failure.
            if grep -E -i 'ERROR|failed to build|Step [0-9]+/[0-9]+ failed|failed to fetch|npm: not found|Could not resolve|unable to access' "$BUILD_LOG_FILE"; then
              PROCESSED_BUILD_OR_UP_ERROR=true
              echo "--- Relevant lines from Docker build log above ---"
            else
              # If specific grep fails, but file exists, show last N lines as a less specific fallback.
              echo "No specific critical error markers found in Docker build log via grep. Displaying last 20 lines as fallback:"
              tail -n 20 "$BUILD_LOG_FILE"
              PROCESSED_BUILD_OR_UP_ERROR=true # Still consider it processed.
            fi
          fi

          if [ "$PROCESSED_BUILD_OR_UP_ERROR" = false ]; then
            if [ -f "$UP_LOG_FILE" ]; then
              if grep -E -i 'ERROR|Cannot start service|failed| unhealthy|exited with code' "$UP_LOG_FILE"; then
                PROCESSED_BUILD_OR_UP_ERROR=true
                echo "--- Relevant lines from Docker up log above ---"
              else
                echo "No specific critical error markers found in Docker up log via grep. Displaying last 20 lines as fallback:"
                tail -n 20 "$UP_LOG_FILE"
                PROCESSED_BUILD_OR_UP_ERROR=true
              fi
            fi
          fi

          if [ "$PROCESSED_BUILD_OR_UP_ERROR" = false ]; then
            echo "No critical errors found in build/up logs, or logs not found. Checking application service ('app') logs..."
            if [ -n "$(docker compose ps -q app)" ] || docker compose ps app | grep -iq 'exited'; then
              # RSpec logs benefit from some context.
              docker compose logs app | grep -E -A 30 'Failures:|Failure/Error:|Failed examples:' \
              || (echo "No RSpec failure markers found in 'app' service logs. Dumping last 50 lines of 'app' service as fallback." && docker compose logs app | tail -n 50)
            else
              echo "The 'app' service does not appear to have been active. No application logs to display."
            fi
          fi

      - name: Stop Docker services
        if: always() # Ensure services are stopped even if previous steps fail
        working-directory: ./ultradex
        run: |
          docker compose down
