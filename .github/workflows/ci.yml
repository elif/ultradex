name: CI

on:
  push:
    branches: [ main ]

jobs:
  build_and_test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Compose and Build services
        working-directory: ./ultradex
        run: |
          set -e # Ensure script exits on first error
          echo "Running docker compose build..."
          docker compose -f docker-compose.yml build > $GITHUB_WORKSPACE/docker_build_output.log 2>&1
          BUILD_EXIT_CODE=$?
          if [ $BUILD_EXIT_CODE -ne 0 ]; then
            echo "Docker compose build failed with exit code $BUILD_EXIT_CODE. Full log:"
            cat $GITHUB_WORKSPACE/docker_build_output.log
            exit $BUILD_EXIT_CODE
          fi
          echo "Docker compose build successful."

          echo "Running docker compose up -d..."
           docker compose -f docker-compose.yml up -d > $GITHUB_WORKSPACE/docker_up_output.log 2>&1
          UP_EXIT_CODE=$?
          if [ $UP_EXIT_CODE -ne 0 ]; then
            echo "Docker compose up -d failed with exit code $UP_EXIT_CODE. Full log:"
            cat $GITHUB_WORKSPACE/docker_up_output.log
            # Also output build log for context if up fails, as it might be related
            echo "--- Docker Build Log (for context as 'up' failed) ---"
            cat $GITHUB_WORKSPACE/docker_build_output.log
            exit $UP_EXIT_CODE
          fi
          echo "Docker compose up -d successful."

      - name: Debug Container Environment
        working-directory: ./ultradex
        run: |
          docker compose -f docker-compose.yml exec -T app sh -c "\
          echo '--- Debugging Container Environment ---'; \
          echo '=== Phase 1: Running as current user (likely root from exec) ==='; \
          echo 'whoami (initial exec user):'; \
          whoami; \
          echo 'pwd (initial exec user):'; \
          pwd; \
          echo 'Listing /usr/src/app (initial exec user context):'; \
          ls -la /usr/src/app; \
          echo 'Stat /usr/src/app/config (initial exec user context):'; \
          stat /usr/src/app/config || echo 'ALERT: stat /usr/src/app/config failed (initial exec user)'; \
          echo 'Stat /usr/src/app/config/environment.rb (initial exec user context):'; \
          stat /usr/src/app/config/environment.rb || echo 'ALERT: stat /usr/src/app/config/environment.rb failed (initial exec user)'; \
          echo 'Stat /usr/src/app/spec/rails_helper.rb (initial exec user context):'; \
          stat /usr/src/app/spec/rails_helper.rb || echo 'ALERT: stat /usr/src/app/spec/rails_helper.rb failed (initial exec user)'; \
          echo 'Mount info for /usr/src/app (initial exec user context):'; \
          df -h /usr/src/app; \
          mount | grep /usr/src/app || echo 'INFO: /usr/src/app not found in mount output (initial exec user)'; \
          echo '=== Phase 2: Switching to appuser ==='; \
          su appuser -c '\
            echo \"--- Running as appuser (inside su appuser -c) ---\"; \
            echo \"whoami (after su appuser): \$(whoami)\"; \
            echo \"Initial PWD for appuser: \$(pwd)\"; \
            echo \"Attempting: cd /usr/src/app\"; \
            cd /usr/src/app || echo \"ALERT: \$(whoami) FAILED to cd to /usr/src/app\"; \
            echo \"PWD after cd: \$(pwd)\"; \
            echo \"\"; \
            echo \"--- File & Directory Checks (as appuser in \$(pwd)) ---\"; \
            echo \"Listing current directory (\$(pwd)) with ls -la .:\"; \
            ls -la .; \
            echo \"Listing ./config (ls -la ./config):\"; \
            ls -la ./config || echo \"ALERT: ./config not found or not listable by \$(whoami)\"; \
            echo \"Listing ./spec (ls -la ./spec):\"; \
            ls -la ./spec || echo \"ALERT: ./spec not found or not listable by \$(whoami)\"; \
            echo \"\"; \
            echo \"Checking ./config/environment.rb with ls -laL ./config/environment.rb (dereference symlinks):\"; \
            ls -laL ./config/environment.rb || echo \"ALERT: ./config/environment.rb not found (ls -laL) by \$(whoami)\"; \
            echo \"Stat ./config/environment.rb:\"; \
            stat ./config/environment.rb || echo \"ALERT: stat ./config/environment.rb failed for \$(whoami)\"; \
            echo \"Head of ./config/environment.rb (first 5 lines):\"; \
            head -n 5 ./config/environment.rb || echo \"ALERT: head ./config/environment.rb failed for \$(whoami)\"; \
            echo \"\"; \
            echo \"Checking ./spec/rails_helper.rb with ls -laL ./spec/rails_helper.rb:\"; \
            ls -laL ./spec/rails_helper.rb || echo \"ALERT: ./spec/rails_helper.rb not found (ls -laL) by \$(whoami)\"; \
            echo \"Stat ./spec/rails_helper.rb:\"; \
            stat ./spec/rails_helper.rb || echo \"ALERT: stat ./spec/rails_helper.rb failed for \$(whoami)\"; \
            echo \"Head of ./spec/rails_helper.rb (first 5 lines):\"; \
            head -n 5 ./spec/rails_helper.rb || echo \"ALERT: head ./spec/rails_helper.rb failed for \$(whoami)\"; \
            echo \"Grep for require_relative in ./spec/rails_helper.rb:\"; \
            grep require_relative ./spec/rails_helper.rb || echo \"ALERT: require_relative not found in spec/rails_helper.rb by \$(whoami)\"; \
            echo \"Cat -A ./spec/rails_helper.rb (showing non-printing chars, first 10 lines for brevity):\"; \
            cat -A ./spec/rails_helper.rb | head -n 10 || echo \"ALERT: cat -A ./spec/rails_helper.rb failed for \$(whoami)\"; \
            echo \"\"; \
            echo \"--- Environment Checks (as appuser after attempting to source RVM) ---\"; \
            echo \"Sourcing RVM (/home/appuser/.rvm/scripts/rvm)...\"; \
            source /home/appuser/.rvm/scripts/rvm || echo \"ALERT: Failed to source RVM for \$(whoami)\"; \
            echo \"RVM Info (env | grep RVM):\"; \
            env | grep RVM; \
            echo \"Ruby version (ruby -v):\"; \
            ruby -v || echo \"ALERT: ruby -v failed for \$(whoami)\"; \
            echo \"Bundler version (bundle -v):\"; \
            bundle -v || echo \"ALERT: bundle -v failed for \$(whoami)\"; \
            echo \"GEM_HOME: \$GEM_HOME\"; \
            echo \"GEM_PATH: \$GEM_PATH\"; \
            echo \"Ruby Load Path (\$LOAD_PATH) - joined by newlines:\"; \
            ruby -e \\\"puts \\\\\\\$LOAD_PATH.join(\\\\\\\"\\\\\\\\n\\\\\\\")\\\" || echo \"ALERT: Failed to get Ruby \\\$LOAD_PATH for \$(whoami)\"; \
            echo \"Bundle check:\"; \
            bundle check || echo \"ALERT: bundle check failed for \$(whoami)\"; \
            echo \"\"; \
            echo \"--- Path Resolution Test (as appuser from /usr/src/app/spec) ---\"; \
            echo \"Attempting to resolve path: Dir.chdir(\\\\\\\"/usr/src/app/spec\\\\\\\"); puts File.expand_path(\\\\\\\"../config/environment.rb\\\\\\\")\"; \
            ruby -e \\\"Dir.chdir(\\\\\\\"/usr/src/app/spec\\\\\\\") do; puts File.expand_path(\\\\\\\"../config/environment.rb\\\\\\\"); end\\\" || echo \\\"ALERT: Ruby test for resolving path failed for \$(whoami)\\\"; \
            echo \"--- End of appuser debug ---\"; \
          '

      - name: Run RSpec tests
        working-directory: ./ultradex
        run: |
          docker compose -f docker-compose.yml exec -T --user root app sh -c "cd /usr/src/app && chmod 777 Gemfile.lock || true; su appuser -c 'source /home/appuser/.rvm/scripts/rvm && cd /usr/src/app && bundle exec rspec'"

      - name: Output Failure Logs
        if: failure()
        working-directory: ./ultradex # pwd is $GITHUB_WORKSPACE/ultradex
        run: |
          BUILD_LOG_FILE="$GITHUB_WORKSPACE/docker_build_output.log"
          UP_LOG_FILE="$GITHUB_WORKSPACE/docker_up_output.log"
          PROCESSED_BUILD_OR_UP_ERROR=false

          # Intentionally minimal echos now, only outputting found errors or final status.

          if [ -f "$BUILD_LOG_FILE" ]; then
            # Grep for critical errors, show only matching lines.
            # Added 'npm: not found' directly based on observed failure.
            if grep -E -i 'ERROR|failed to build|Step [0-9]+/[0-9]+ failed|failed to fetch|npm: not found|Could not resolve|unable to access' "$BUILD_LOG_FILE"; then
              PROCESSED_BUILD_OR_UP_ERROR=true
              echo "--- Relevant lines from Docker build log above ---"
            else
              # If specific grep fails, but file exists, show last N lines as a less specific fallback.
              echo "No specific critical error markers found in Docker build log via grep. Displaying last 20 lines as fallback:"
              tail -n 20 "$BUILD_LOG_FILE"
              PROCESSED_BUILD_OR_UP_ERROR=true # Still consider it processed.
            fi
          fi

          if [ "$PROCESSED_BUILD_OR_UP_ERROR" = false ]; then
            if [ -f "$UP_LOG_FILE" ]; then
              if grep -E -i 'ERROR|Cannot start service|failed| unhealthy|exited with code' "$UP_LOG_FILE"; then
                PROCESSED_BUILD_OR_UP_ERROR=true
                echo "--- Relevant lines from Docker up log above ---"
              else
                echo "No specific critical error markers found in Docker up log via grep. Displaying last 20 lines as fallback:"
                tail -n 20 "$UP_LOG_FILE"
                PROCESSED_BUILD_OR_UP_ERROR=true
              fi
            fi
          fi

          if [ "$PROCESSED_BUILD_OR_UP_ERROR" = false ]; then
            echo "No critical errors found in build/up logs, or logs not found. Checking application service ('app') logs..."
            if [ -n "$(docker compose -f docker-compose.yml ps -q app)" ] || docker compose -f docker-compose.yml ps app | grep -iq 'exited'; then
              # RSpec logs benefit from some context.
              docker compose -f docker-compose.yml logs app | grep -E -A 30 'Failures:|Failure/Error:|Failed examples:' \
              || (echo "No RSpec failure markers found in 'app' service logs. Dumping last 50 lines of 'app' service as fallback." && docker compose -f docker-compose.yml logs app | tail -n 50)
            else
              echo "The 'app' service does not appear to have been active. No application logs to display."
            fi
          fi

      - name: Stop Docker services
        if: always() # Ensure services are stopped even if previous steps fail
        working-directory: ./ultradex
        run: |
          docker compose -f docker-compose.yml down
